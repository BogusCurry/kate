// kate: space-indent on; indent-width 4; replace-tabs on; remove-trailing-spaces all;
// kate: syntax pascal; indent-mode pascal;

// these variables are understood by the pascal indenter ...
// kate: cfgIndentCase false;          // indent elements in a case statement
// kate: cfgIndentBegin 2;            // indent 'begin' this many spaces
// kate: debugMode false;              // show how indent is determined
// kate: cfgAutoInsertStar true;      // auto insert '*' in (* ... *)-comments
// kate: cfgSnapParen true;           // snap ')' to '*)' in comments

(**********************************************   // check: indent OK?
 *                                            *
 *       Commment to test alignment           *
 *                                            *
 *                                            *
 **********************************************)

 (*************************************************************************
 Another Comment

 Relative alignment should be kept ...
       After indent, first character of this line should 
       still remain under the 'v' in relative

 *************************************************************************)

program fred;

uses bbb;

label fred001;
var   i: integer;

const const0 = 0;
    c33 = 12;
    const1 = 17;
    const2 = 18.4;

type x = record a: real; c : char end;

   // r = record ... vs unfinished typedef
    rType = record  // cr here ==> type def
                a: aType;       // this can be realigned manually
                b: bType;       // should follow line above
                c: cType
            end;

    colourType =
       { unfinished type declaration }
        ( red,    // CHECK: everything should line up below this
          orange, // this must follow line above
          green,
          blue,
          indigo,
          yellow,
          violet
          // CHECK: the comments should line up as well
          // closing paren should align to list when it's left shifted
          //                            to opening paren otherwise
        );

    otherTypeDef = integer;

// CHECK: next line should keep its relative alignment
   {ant}
    ant = RECORD CASE F: BOOLEAN OF
                 TRUE: ( fred : REAL;
                         joe  : INTEGER;
                       );  // parens should line up
                 FALSE: (  ted : ARRAY[
                                          1..16
                                      ] OF BOOLEAN;
                           moe: CHAR;
                        );
             END; // 'case' + 'record' share same 'end'



var a: real;

    RW:  ARRAY [AASY..ZZSY]
             OF   (*RESERVED WORDS*)   PACKED ARRAY [1..RWLENGTH,
                                                     2..66 ]     // CHECK: this line should be indented
                                                  OF CHAR;    // CHECK: this line should be indented from array

    RW:  ARRAY [AASY..ZZSY] OF   (*RESERVED WORDS*)
             PACKED ARRAY [1..RWLENGTH] OF CHAR;

var
    sym : keysymbol;
    pos : hashIndex;
    len : charLenType;


type tR = record
             i: integer;   // CHECK: can be aligned manually, but default indented from record
             r: real;      // should align with line immediately above
             a: array[1..11] of char;

             case boolean of
             true: ( fred : real;
                     joe  : integer;
                   );  // parens should line up
             false: (  ted : array[
                                     1..16
                                  ] of boolean;
                       moe: char;
                    );
         end; // 'case' + 'record' share same 'end'

    tArray = array[0..17] of real; // should indent wrt 'type'

type    colourType = (
              red,    // CHECK: this line can be adjusted manually
              orange, // this must follow line above
              green,
              blue,
              indigo,
              yellow,
              violet
              // CHECK: the comments should line up as well
              // closing paren should align to list when it's left shifted
              //                            to opening paren otherwise
              );

    blah = char;  // should align after type

    optionset = set of options;

var
    r1: record
           i:    integer;
           r:    real;                   // should line up with first member
           a:    array[0..7] of char;
       end;  // CHECK: end is outdented relative to first member

    optionset : set of options;

    options : (    crsupp,crbefore,blinbefore,
                   dindonkey,dindent,spbef,
                   spaft,gobsym,
                   inbytab,   { indent current margin (was indent from symbol pos) }
                   crafter,
                   finl            { force symbol to follow on same line as previous symbol }
              );

    optionset = set of options;

    aa: array[   1..9, // should be indented after cr
                 3..22 ]
            of ( crsupp,crbefore,blinbefore,
                 dindonkey,dindent,spbef,
                 spaft,gobsym,
                 inbytab,   { indent current margin (was indent from symbol pos) }
                 crafter,
                 finl            { force symbol to follow on same line as previous symbol }
               );

    aaa: array[ 1..3,
                4..5,
                12..11 ]
             of record // cr after here should indent from record
                    a: array[1..6] of char;
                    i: integer;
                end;

                 { CHECK: following text should keep indent relative to open/close brace
                          when annotating, behavior of "external", "end" and possibly other keywords
                          depends on whether we are in procedure declaration,
                          item (var/const/type) declaration, or statements
    NOTE:  here we see why it's better to make the comment align with the
           following line (ie the procedure call) rather than the preceding
           line (ie the 'end'.  Easy in theory, messy in practice.
                 }


procedure AVeryVeryLongFunctionName(const A : tRealArrayType;
                                    N : tIntegerType;
                                    var H : tRealArrayType); forward;

(*************************************************************************
CHECK:   comment is correctly aligned with precedinging statement

Input parameters:
A       -   description

N       -   longer description, but
            still preserving relative format

Output parameters:
H       - other meaningful description

Result:
   True, if successful
   False, otherwise
*************************************************************************)

var size : (small, medium, large);
    fred : real;

var   r : record i: integer; c: char end;

    a: array[ 1..9,    // should be indented after var
              'a'..'z'        // non-code, should line up with opening arg
            ] of integer;

begin (* AVeryVeryLongFunctionName *)

    if a then
      begin
        s1;
16:
        f(32);  //CHECK: label forced to margin, statement is on new line with comment
      end;

    for i := 0 to 100 do
      begin
        with p^ do
            begin s1; s2; s3 end
      end;

    with p^ do
        begin s1; s2; s3 end;

    for i := firstCh to lastCh do chtype[chr(i)] := none;
    value['0'] := 0; value['1'] := 1; value['2'] := 2;
    value['3'] := 3; value['4'] := 4; value['5'] := 5;
    value['6'] := 6; value['7'] := 7; value['8'] := 8;
    value['9'] := 9;
    value['A'] := 10; value['B'] := 11; value['C'] := 12;
    value['D'] := 13; value['E'] := 14; value['F'] := 15;
    value['a'] := 10; value['b'] := 11; value['c'] := 12;
    value['d'] := 13; value['e'] := 14; value['f'] := 15;

    IF NOT (CH IN ['{','}']) THEN
    // comment
      BEGIN  IF CH <= 'Z' THEN CMDCH := CH ELSE CMDCH := CHR(ORD(CH)-ORD('a')+ORD('A') );
        NEXTCH;
        IF CMDCH = 'L' THEN
            COMMAND(LISTON)
        ELSE IF CMDCH = 'T' THEN
            COMMAND(TRACEON)
        ELSE IF CMDCH = 'I' THEN
            COMMAND(INCLUDE)
        ELSE IF CMDCH = 'Z' THEN
            REPEAT
                BEGIN
                  www.fred.com;
                  REPEAT commandIn UNTIL numRem = 0;
                  s1;
                  s2;
                END;
            UNTIL False
        ELSE IF CMDCH = 'Q' THEN begin
            COMMAND(QUIET)
        end ELSE IF CMDCH = 'V' THEN
            COMMAND(VERBOSE)
        else if COMMAND.STRVAL = 'unknown' then
          begin
            IF
                    (numStr[0] >= 0) AND
                    (numStr[1] IN ['+', '-', '0' .. '9', '?']) // CHECK: indent
            THEN
                Power.Supply := '"AC' ELSE Power.Supply := '"DC'
          end else  if CommandResult.Str = 'helpIamLost' then begin
              Power.Supply := SetPowerSupplyCommands(Plus15V.Increase(Amps));
          end else if (line = 'SHORT') OR (line = 'OPEN') THEN  BEGIN
              OpenCircuit;
              {*smoke billows out*}
              IF SPARKS THEN
                BEGIN
                  SPARKS := FALSE;
                  ShutDown
                END
          END ELSE IF
              (line = 'OPEN') OR (line = 'CLOSED') THEN
            BEGIN;
              AddFuse(Low);
              IF SPARKS THEN
                BEGIN;
                  SPARKS := False;
                  CircuitBreaker(wishfulThinking)
                END else if cond then
                    statement;
            END ELSE IF (line = 'PLUS') OR (line = 'MINUS') THEN Transform(RedPhase)
        ELSE IF (line = 'RED') OR (line = 'BLACK') THEN Transform(BluePhase)
        ELSE IF line = 'XX' THEN Transistor
        ELSE IF line = 'YYYY' THEN SetCurrent(FiveAmps)
        ELSE IF line = 'QQQQ' THEN SetPower(FiveWatts)
        ELSE IF line = 'AAAAA' THEN Power(FiveAmps)
        ELSE IF
           {* QWERTY COMMENT LLLLLLLLL ####### *}
           line = 'SSSSS' THEN
          BEGIN
            actualphase := YellowPhase;
            AdjustLinePhase(NewPhase);
          END
        ELSE IF
                line = 'Noisy' THEN Filter
        ELSE IF line = 'BLUE' THEN
          BEGIN
            AdjustLinePhase(XPhase);
            Erase := True
          END ELSE IF
              line = 'RED' THEN BEGIN Swap; Hope END
        ELSE IF
           line = '415' THEN iNumPut415
        ELSE IF
           // a statement like this has no chance of being correctly indented ...
           // otoh, it shouldn't turn out catastrophically wrong.
           line = 'REFL' THEN FOR i := 1 TO numLines DO
                                       WriteLn('level=', powerLevel[i], ' ', name[i]+'='+power[i])
        ELSE IF
           line = 'HIGH' THEN reduce
        ELSE IF
           line = 'LOW' THEN increase
        ELSE IF
           line = 'END' THEN
          BEGIN
            WHILE powerlevel[NumPowers] = level DO NumPowers := NumPowers-1;
            level := level-1;
          END
        ELSE IF
           line = 'WAIT' THEN
          BEGIN
            Z := ReActivate;
            Z := X*240.0 + i*Y*240;
            ROTATE(ABS(Z))
          END
        ELSE IF line = 'HILD' THEN motor(induction)
        ELSE IF (line = 'REV') THEN        BEGIN
            v := YellowPhase;
            IF (NOT(v IN [#14..#240])) THEN
                WriteLn(' POWER SUPPLY OUT OF SPEC') ELSE specValue := v;
            specValidate
        END
        ELSE IF (line = 'OK') THEN BEGIN
            IncomingSupply := True; specValidate END
        ELSE IF (line = 'NOK') THEN BEGIN IncomingSupply := False; specValidate END
        else    begin
            GeneratedPowerLine.IncreasePower(
                          'Unknown input power "%s"', [SwitchPower.Current]);    // CHECK: string should not cause problems
        end;
      END;


end (* AVeryVeryLongFunctionName *) ;  // check that only necessary work is done to align


FUNCTION f(
            alf : real;
            fred : integer;  // should line up with alf
            bill : boolean;
            joe: char;
          );
VAR s : string;
BEGIN s := do; WriteLn(s) END;


procedure getbyte;   // CHECK: cr after this line is **not** indented

var  // CHECK: cr after this line **is** indented
    ch : char;

begin

   // need to consider:
   // if c then begin s1; s2 end; // strip these lines
   // begin   // normal case
   // end     // normal case
   // end else if begin // should be OK since /end/ tested last
   // need to consider ...
   //                  if c1 then begin s1; s2 end
   //                  else s3;
                                        // <-- align this line

                                        { checking multi line statements }


    while aaaaaaaaaaaaaaaaaaaaaaa
            and bbbbbbbbbbb  do
        if c1 then begin
            s1;
            for i := 1
                  to 10 do
                s3
        end;
    s4;
    s5; // the ';' here links to the ';' after the 'case' below

    if c1 then
        case e01 of
        111111111:    s1;
        23:
            writeln(x,
                    'fred',
                    notCaseValue:4,
                    x);

        2:
            case e05 of
            1: s1;   // CHECK: cr here should go to new case value!
            88:
                s3;

            2:  begin
                  s2;
                  s3;
                end;

            3:
                case e09 of
                1: s1;   // CHECK: cr here should go to new case value!
                88:
                    s3;

                2:
                    begin
                      s2;
                      s3;
                    end;

                3: s3;
                4,5,6..9: s6;

                otherwise
                    writeln('lots');
                    writeln(' and lots');
                end; {case}

            4,5,6..9: s6;

            otherwise
                writeln('lots');
                writeln(' and lots');
            end; {case}

        4: if e then
              begin   // CHECK: should be indented after case value
                s1;
                s2
              end
            else if ee
                    and ee1
            then begin
                s1;
                s2;
            end;

        99: a:= 13;
        100: if e then s1;

        333333: if c then
              begin // CKECK: should indent one level from case value
                s3; // CHECK: should be indented another level
                s4
              end;

        30:
            if c then begin // cr here is OK
                s3;
                s4
            end;
        4: writeln('fred',
                   notCaseValue:4,
                   x
                  );
        s4;             // incorrect code, indenter should expect a case value here
        88:
            if c1 then
              begin
                s6;
                s7
            else
                s8
              end;     // stress test: else/end crossed over !!
        end; {case}
    s6;

    a := 1;
    a := 2;
    a := 3;
    if c1
            and c2 then begin // can be aligned manually
        a := 12;             // should be indented one level from if statement
        f(x)
    end;
    if c1
            and c2  // can be aligned manually
    then
      begin
        a := 12;             // should be indented one level from if statement
        f(x)
      end;
    if c then
        if c then
            if c then
                repeat s1 until c
            else
                a[    i,
                      j,
                      zzzzzzzzzz[ a,
                                  b
                                ],
                      vvvvv   // CHECK: indent lines with zzzzzzzzz
                 ] := x
                      + 10;
    if a then
        if b then
            if c then begin
                s1;
                s2;
            end; {if}
    while z do s1;


    while not (  ((currchar.value = '*') and (nextchar.value = ')'))
                 or (currchar.value = '}') // args should line up inside parens
                 or (nextchar.name = endofline)
                 or ( sym^.length >= maxsymbolsize-2 )
                 or (nextchar.name = filemark)) do
        storenextchar(sym^.length,sym^.value);  // should be indented from while

    while not (currchar.value = '*') and (nextchar.value = ')')
          or (currchar.value = '}')           // possible to realign first line manually
          or (nextchar.name = endofline)      // CHECK: other lines should follow first line  // CHECK:: indents line up
          or ( sym^.length >= maxsymbolsize-2 )
          or (nextchar.name = filemark) do
        storenextchar(sym^.length,sym^.value);  // should be indented from while

    while not (currchar.value = '*') and (nextchar.value = ')')
          or (currchar.value = '}')           // possible to realign first line manually
          or (nextchar.name = endofline)      // CHECK: other lines should follow first line  // CHECK:: indents line up
          or ( sym^.length >= maxsymbolsize-2 )
          or (nextchar.name = filemark)
    do
        storenextchar(sym^.length,sym^.value);  // should be indented from while

    dblchar[becomes] := ':=';
    dblchar[opencomment] := '(*';  // not start of comment!
    sglchar[semicolon] := ';';
    sglchar[colon]     := ':';
    sglchar[equals]    := '=';
    sglchar[openparen] := '(';
    sglchar[closeparen] := ')';
    sglchar[period]    := '.';
    sglchar[opencomment] := '{';
    sglchar[closecomment] := '}';

    with nextchar do
        if eof(infile) then
          begin
            name := filemark;
            if ch in ['0'..'9'] then
                name := digit
            else if ch = '''' then begin
                name := quote
            end else if (ch = blank) or (ch = chr(tab)) then
                name := space
            else name := otherchar
                value := blank
          end
        else if eoln(infile) then
          begin
            name := endofline;
            value := blank;
            if c1 then begin s1; s2 end
            else s7;
            inlines := inlines + 1;
            readln(infile)
          end
        else
          begin
            read(infile,ch);
            value := ch;
            if ch in ['a'..'z','A'..'Z','_'] then
                name := letter
            else
                if ch in ['0'..'9'] then
                    name := digit
                else if ch = '''' then while c do
                  begin
                    s1;
                    name := quote
                  end;
                else if (ch = blank) or (ch = chr(tab)) then
                    name := space
                else name := otherchar
          end;

          { CHECK:
                    # pp lines go to start of line, unless they are in a comment
          }

#if
#endif
    cccccc; // CHECK: this aligns with code
# // CHECK: preprocessor lines go to start of line

    if c1 then
        if c2 then while c do
            s
        else
            s2;
    s3;
    s4;

end; { getbyte }


function f1( var z: integer;
             var p,q : real;
             t : boolean	   ) : integer; // indentation should line up

type   tArray = array[0..17] of real;

    r= record a: integer; c: char; end;

    // nested variant record - too hard to get right. tough
    MyRec = Record
                X : Longint;
                Case byte of
                1,2,8 : (Y : Longint;
                         case byte of
                         3 : (Z : Longint);   // CHECK: parens inside parens aligned correctly
                        );
            end;

    commands = (    crsupp,crbefore,blinbefore,
                    dindonkey,dindent,spbef,
                    spaft,gobsym,
                    inbytab,   { indent current margin (was indent from symbol pos) }
                    crafter,
                    finl            { force symbol to follow on same line as previous symbol }
               );

    tR = record
             i: integer;  // should indent after record
             r: real;
             a: array[1..11] of char;

             case boolean of
             true:( a: int);
             dontKnow:
                 (z: real;
                  fred : real;       // should be indented after case value
                  joe  : integer;
                 );
             false:
                 (  ted : array[
                                   1..16
                               ] of boolean;
                    moe: char; // should align to ''ted''
                 );
         end; // end of case + end of record

    commandset = set of commands;       // should be aligned to 'record', not 'case'

begin { f1 }
    case currsym^.name of

       { for procs, etc just record that we have one, wait for name }
    progsym, procsym, funcsym: begin
          symbol_seen := procsym;
          proc_state := proc_header;
          annotate_push( procsym );
        end;
    s1;                   // coding error, a case value should be here
       { remember we are in the declaraions part }
    varsym, typesym, constsym, labelsym:
        proc_state := proc_declarations;

        { if it's a proc, there will be no begin/end ==> pop info we just saved
        if it's an external var ==> do nothing  }
    forwardsym, externalsym:
        if proc_state = proc_header then
          begin
            sym := annotate_pop;
            tok := annotate_pop_tok;
            if annotate_trace in traceFlags then
                writeln( 'undo ', tok.val:tok.len );
          end;

          { if a proc has just occurred, this is its name
          otherwise, remember it, just in case it's a record name }
    othersym:
        begin
          if symbol_seen = procsym then begin
              tok.val := currsym^.value;
              tok.len := currsym^.length;
              annotate_push_tok( tok );
              symbol_seen := othersym;
          end
          else begin
              annotate_temp_tok.val := currsym^.value;
              annotate_temp_tok.len := currsym^.length;
          end;
        end;

        { we have the name, push it so the end symbol can get it back }
    recordsym: begin
          annotate_push_tok(annotate_temp_tok);
          annotate_push( recordsym );
          symbol_seen := recordsym;
        end;

        { we must remember these so they can pushed if the begin symbol occurs }
    ifsym, forsym, whilesym, withsym:
        begin
          symbol_seen := currsym^.name;
        end;

        { this is the second part of an if statement }
    elsesym:
        symbol_seen := ifsym;

        { if in a declaration ==> ignore
        if in a statement (assume case statement) ==> prepare for possible begin following }
    colon:
        if proc_state = proc_statements then
            symbol_seen := colon;

         { reset symbol_seen }
    semicolon:
        symbol_seen := semicolon;

        { could be the begin of a proc
        ==> get value, leaving it for the corresponding end symbol
        or it could be part of an if, etc,
        ==> push the symbol so the end symbol knows what to do  }
    beginsym: begin
          proc_state := proc_statements;
          if symbol_seen in [ifsym, forsym, whilesym, withsym, elsesym, colon] then begin
              annotate_push( symbol_seen );
          end
          else begin
              sym := annotate_peek;
              if sym = procsym then begin
                 { this is a proc begin, add annotation }
                  annotate_pending_tok := true;
                  annotate_temp_tok := annotate_peek_tok;
              end
              else
                begin
                  if annotate_trace in traceFlags then
                      writeln( infilename,' line ', inlines, ': orphaned begin found' );
                  annotate_push( nosymbol );
                end
          end;
        end;

        { push the symbol so the end symbol can get it back }
    casesym: annotate_push( casesym );

       { end of proc, end of record  ==> pop name
       end of if, etc statement    ==> pop symbol
       end of case item (colon)    ==> ignore
       end of record ==> check if named record  }
    endsym:
        begin
          symbol_seen := endsym;
          sym := annotate_pop;
          if sym = recordsym then begin
              annotate_temp_tok := annotate_pop_tok;
              if annotate_temp_tok.val[1] in ['A'..'Z','a'..'z'] then
                  annotate_pending_tok := true;
          end
          else if sym = procsym then
            begin
              annotate_pending_tok := true;
              annotate_temp_tok := annotate_pop_tok;
            end
          else if sym = ifsym then begin
             { if there's an else part, don't do an annotation here }
              if nextsym^.name <> elsesym then
                begin
                  annotate_pending := true;
                  annotate_temp := sym;
                end
          end
          else if sym in [forsym, whilesym, withsym, casesym] then begin
              annotate_pending := true;
              annotate_temp := sym;
          end
          else if sym = colon then
            begin
              if annotate_trace in traceFlags then
                  writeln( 'case item not annotated' );
            end
          else begin
              if annotate_trace in traceFlags then
                  writeln( infilename,' line: ', inlines, ' end symbol found but not handled' );
          end;
        end;
    end; { case }

    if annotate_pending then begin
        if nextsym^.crsbefore > 0 then
          begin
            { rest of line is empty }
            insert_annotation(annotate_temp);
            annotate_pending := false;
          end else if nextsym^.name in [opencomment,
                                        closecomment] then
            begin
                                          { there's another comment already on the same line }
              if annotate_trace in traceFlags then
                  writeln( infilename,' line: ', inlines, ' annotate ', keyword[annotate_temp], ' abandoned' );
              annotate_pending := false;
            end
        else if (nextsym^.name <> semicolon) then begin
            insert_annotation(annotate_temp);
            annotate_pending := false;
        end;
    end;

    if annotate_pending_tok then
      begin
        if nextsym^.crsbefore > 0 then begin
           { rest of line is empty }
            insert_annotation_tok( annotate_temp_tok );
            annotate_pending_tok := false;
        end
        else if nextsym^.name in [opencomment, closecomment] then begin
           { there's another comment already on the same line }
            if annotate_trace in traceFlags then
                writeln( infilename,
                         ' line: ', inlines,
                         ' annotate ', annotate_temp_tok.val:annotate_temp_tok.len, ' abandoned'
                       );
            annotate_pending_tok := false;
        end
        else if not (nextsym^.name in [semicolon, period]) then begin
            insert_annotation_tok( annotate_temp_tok );
            annotate_pending_tok := false;
        end;
      end;
end; { f1 }


function f2( p: boolean;
             var q: real;
             var x: ttype;              // should line up with first param
             var c: char;

             var i1, i2: integer;

             ch: char;
             z: boolean
           ) : real;

var
    a: integer;
    b: boolean;

begin { f2 }

    with floodlePtr^ do
      begin name := '        '; id := nil; next := nil; floodleAddr := 0;
        cow := grass + floodle  // should be indented
      end;

    case e of
    1: s1;   // CHECK: cr here should go to new case value!
    88:
        s3;

    2:  begin
          s2;
          s3;
        end;

    3: s3;
    4,5,6..9: s6;

    otherwise
        writeln('lots');
        writeln(' and lots');
    end; {case}

    if c then begin
        s1;
        a := func( 12,
                   fffff( 89,
                          t
                        ),
                   a // should align with '12'
                 );
    end; // this must be aligned to the 'if' statement


    fredzarmplezzzzzzzzzzzz(       arg1,
                                   arg1,
                                   arg2,
                                   arg3
                           );

    x := f(a) + f(b);


    if (e111) + e2 then fffffffffffff(    func0(  func1(    func2( f3(       arg1,


                                                                             arg2,
                                                                             arg3,
                                                                             arg4
                                                                     ),


                                                                   a1,  // should be aligned with arg f3, not '('
                                                                   a2,
                                                                   a3,
                                                                   a4
                                                                 ),

                                                            aa2,
                                                            aa3,
                                                            aa4,
                                                            aa5
                                                       ),
                                                  bb1,
                                                  bb2,
                                                  bb3,
                                                  bb4
                                               ),
                                          cc1,
                                          cc2,
                                          cc3,
                                          cc4
                                     )
    else if c1 then begin
        s1;
    end;

    nextStmt := 13;

    while c1 do
        if q then
            s1
        else if qq then
          begin
            s2;
            s3
          end;


    if c1
            and c2 then begin // this can be aligned manually
        a := 12;
        s1;
        f(x)
    end;

    if c1
            and c2
    then begin
        a := 12;
        s1;
        f(x)
    end;

    if c1
            and c2 then
      begin
        a := 12;
        s1;
        f(x)
      end;

    if c1
            and c2
    then
      begin
        a := 12;
        s1;
        f(x)
      end;

    if cc1 then
        while c2 do
            f(x);

    while c1 do f(  arg1,
                    arg2  // this should line up with arg1
                 );

    if c4 then f( arg1,
                  arg2
                );

    f1        ( arg1,
                arg2
              );
    fred      (  arg1,
                 arg2
                 arg3
                 arg4,

                 arg5
              );

    ff( arg1,
        arg2
      );

    a[1] := 13;
    repeat
        s1;
        while c3 do begin
            s3;
            while c2 do
              begin
                s4;
                while c4 do begin
                    if c3 then
                      begin
                        s1;
                        s2;
                      end else
                          s3;
                    if c3 then begin
                        s1
                    end else

                        if a then b
                        else
                            if c then d
                            else

                                s2;
                    if c3 then
                        if c4 then
                            s5;

                    s3
                end;
              end
        end
    until c3;


    s5;

    s3;
    while c7 do begin
        s3;
        s4
    end;

    s4
end;

s2
until c1;  // there is no matching repeat here

end;  { f2 }


begin {main program }

    if f1 > 0 then result := f1-1
    else begin
        f1 :=  -23;
    end;

    case e012 of
    2:
        if eeeeeeeeeeeeeeeeee
                or e33333333333
        then
            a := 12
        else
            for iiiiiiiiiii := 12
                            to 89 // CHECK 89 lines up with 12
            do begin
                if very_long_expression
                        or another_very_long_expression
                        and yet_another_very_long_expression then
                    s1;
                s11;
            end;
    1:
        if e
                +e2
                +e3
                +e2
                or 75  // CHECK: follows first continue line
        then
            for i := 1
                    to 89
            do begin
                a := 12 + 24
                          3 +  // CHECK 3 lines up with 24 above
                          19 +
                          25;
                s1 := e1
                      + e2;
            end;
    5:
        f32verylongfunctionnamezzzzzzzzzzzzzzz(
                               z, // user can realign this anywhere
                               a,b, // this should line up with 'z'''
                               c,
                               d,
                               e
                               );

    3: begin
          s0;
          s3;        // bad code, 'end' is missing
          //end;            // missing end, so next few case values interpreted as labels
5:
          if q then z;

          s3;              // code error - case value belongs here, not statement
5:
          if c2 then s2;

16:
          if c2 then
              s1;
17:
          if c2 then begin s1; s2 end;

4:
          if a then begin
              s2;
              s3 // no trailing semi, but it indents
          end;
        end; { ** bad code ** }   // crossed begin/end - matches '3: begin' above


    2: s2;
    3: while c4
            and e3  do // CHECK: should indent beyond while
            s8;
    1: s1;
    {
    23:
    }
    23: s1;
    s2:
        begin
          s2
          s3 // no trailing semi in line above, but it indents correctly
        end;         // need ';' to force alignment with new case value
    otherwise if a then b;
        if c0 then  begin
            if c1 then begin
            // it does!!
                if c3 then
                    write(              // CHECK: deeply nested levels of parens
                          f(5.5),
                          'test',   // should be aligned
                          notCaseValue:4,
                          f1(8,8),
                          ff( a,
                              b( f(13),
                                 12,
                                 x
                               ),
                              c( g(55) ),

                            ));

            end else  // statement unfinished
    otherwise       // duplicate eotherwise
        if a then begin
            b
        end else if a1 then begin
            c;
            c;
            if a
                    and a1 then
                b
            else
                c;   { CHECK: outdents only when 'c' is followed by ';' }
            if a then begin
                b;
                b1;
            end else
                s3;
            if a then b else c;
            if a then
                b
            else
                c;
            if a then b
            else f( arg,
                    arg2,
                    a1,
                    a2
                    # this is a pp line!!     // bug! silly place to put a pp line
                    f( a,
                       b
                     ));

            if a then
                b
            else if c1 then
                s1;
            if c2 then begin
                s33;
                s34
            end;    { !!! classic error, shouldn't be a semi colon here }
            else if c3 then begin
                s44;
                s45
            end else begin
                s;
                s;
            end

        end else if c1 then begin // comment
            s3
        end;

        while c3 do
            s4;
        end;     // spurious end

        s0;
        s1;
        s2;
        s3;
    end // case e012 of
    else if c2 then begin  // spurious else

        ss;

        if c1 then begin
            write( 'test',
                   notCaseValue:4
                 )
        end else      // this else has no statement
    end    else begin { should still be in sync }

        s1;

        s1;



        s2
    end;

    f(   a,
         b,
     )

     ff(  a,
          b,
          c
       )
       ))

       writeln( 'this is a string ', n:1, ' ', ' ', r:10:2 );

    with p do
      begin

      end;

    with p065 do
      begin
        x := 2;
      end;
    case e07 of
    0:
    1:  s1;
    2:  begin
          s2;
          s3;
        end;
    3: s3;
    12:

    15:
    4,5,6..9: begin s1; end;
    otherwise
        s6;


        s3;
        s1;

        s2;

        while e and
                e2 DO begin { comment }
            s0;
            s33;
            s44;
        end;

        if e97 then begin
            s3;
label:
            while c103 do begin
                s4;
                q := 0;
                case e of
                12,13..16,20: begin
                      s2;
                      s3;
                    end;
                8: writeln( 'test',
                            x,
                            r:4
                          );
                9:

                end;
                while c1
                   and c2 do begin
                    s5;
                    s9;
                end;

                s;
                s;
                s1;
                if e105 then
                    if c2 then begin

                        s3;
                    end; // if

                case e11 of
                2..4,5: begin
                      s1;
                      s2
                    end;


                3: a:= 13;


                89:

                    case e12 of
                    2,3:
                        a:=13;
                    2: begin
                          a:= 13
                        end;
                    5,6,
                    7:
                    otherwise

                        s3;
                        s4;
                    end;  // case e12 of

                otherwise


                    s4;
                    s5;
                    if c2 then
                        s5
                end; // case e11 of

                s3;

            end; // while c103

        end; // if e97

        repeat
            s3;
            s4;
        until c1;

        s0;
        s1;

        if e then begin
            s3;
            s4;
            s0;

            s1;

            s1;
            s1;
        end;

        repeat
            ss;
            s2;
            if e then
                ss;
            s3;
            s1;
        until e;

        if e then begin
            s1;
            s3;
            if e then begin
                s3;
                s5;
            end;
            s6;
            s2;
        end;


        of:=2; // more bad code

        repeat
            s1
        until c;


        a := 123456789;
        IF (e1) or  (* comment *)
                (e2)  then

          begin // CHECK: the begin should follow 'if' line, not 'then' line

            if e then begin s end
            else begin
                s1;
                s2;
            end;

            if e then
                s0;
            if e then begin
                s1;
                s2;       (  // unattached parens

                          )
                          s;  // problem caused by unattached parens
            end
            123456
            { comment }

            if e4 then
                while e5 do begin
                (* ...
                 *  CHECK: stars should line up
                 *
                 *
                 *)
                    (aa)
                    if a then b;   (* qwe
                                    *rty *)
                        cc;
                    s;
                    // comment

                end;


            f( a, b)

            case e of
            12,13: a:=12;
            1,2,3,4..6: writeln(
                                   a, 'TODO:', b );

            567:
                s2;

            88: writeln( 'zzzzzzzzzz',
                         a:12,
                         b
                       );
            99: writeln(
                           z:13,
                           b
                       );
            13: begin
            // no statement
                end;



            0: f( a,
                  b
                );
            12: ff (  a,
                      b
                   );
            (13+12): f( a,
                        37,508.18
                      );



            2: if a = 12 then
                    s1;
                else begin
                    s2;
                end;

            0: writeln( 'zzzzzzzzz',

                        a:3,
                        b:4,
                        'xxxxxxxxxx'

                      );

            1: s1;
            3:



            2: begin

                  s1;
                  s2;
                  s3;
                end;

            5 :
                writeln( 'this is ',
                         'multiline arg list'
                       );




            5:
            6:
                s1;

            9:
                c := 13;

            c2,3,4..7: begin

                  s4;
                  sl;
                  a := 13;

label:  // this is a label, not case value
                  cc;

                  b := 17;

                  writeln( 'strrrrrr', a:4 );

                end;
            c9 :
                s1;

            end; { case e of }
                        // comment
            ff(   a,      // this line aligns with 'end'
                  b,     // CHECK: keep relative indent
                  c
              )
              ;

          end;  // begin CHECK:

ggggg:


        f(
             a,
             b,
             c
         );


        writeln( a,

                 b,

                 b,    { check indent after cr here }
               );

        f(13);
    end; // case e07

end. // main
