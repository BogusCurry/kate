# -*- coding: utf-8 -*-
#
# C/C++ related expansion functions
#
# NOTE Expansion plugin can complete available expansion functions for current
# document. To get help (via tooltip) for the selected expansion function use
# Ctrl+Shift+E shotcut.
#
# Copyright (C) 2010-2013 Alex Turbov <i.zaufi@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys

import kate

import expand
import expand.args as arg_helpers


_CL_SHORTCUT_MAPPINGS = {
    'c'    : 'default_ctor'
  , 'cc'   : 'default_copy_ctor'
  , 'mc'   : 'default_move_ctor'
  , 'd'    : 'destructor'
  , 'dtor' : 'destructor'
  , 'dv'   : 'virtual_destructor'
  , 'vd'   : 'virtual_destructor'
  , 'tf'   : 'template_full_spec'
}


_NS_TPL = '''namespace {0} {{
%{{cursor}}
{1}{2}// namespace {3}
'''

_ANONYMOUS_NS_TPL = '''namespace {{
%{{cursor}}
}}                                                           // anonymous namespace
'''

@expand.jinja('struct.tpl')
@expand.postprocess
def st(*args, **kw):
    ''' Insert a structure definition

        A first mandatory parameter is a structure name.
        Everything after it will be template parameters.
        <pre>
          st(foo, T1..3, U, V)
        </pre>

        will expand into:
        <pre>
          template <typename T1, typename T2, typename T3, typename U, typename V>
          struct foo
          {
          };
        </pre>
    '''
    data = {}
    data['entity_type'] = 'struct'

    # If 'name' parameter present -- use it!
    if 'name' in kw:
        data['entity_name'] = kw['name']

    template_params = []
    for arg in args:
        if arg == 't':
            data['template'] = True                         # It will be a template despite of other params...
        elif 'entity_name' not in data:
            # Assume first not recognized parameter is a class name
            # (if latter was not provided via named parameters)
            data['entity_name'] = arg
        else:
            data['template'] = True
            template_params += arg_helpers.try_expand_params_seq(arg)
    if template_params:
        data['template_params'] = template_params

    if 'entity_name' not in data:
        data['entity_name'] = 'name'

    return data


@expand.jinja('metafunction-class.tpl')
@expand.postprocess
def mfc(*argc, **kw):
    ''' Insert a metafunction class definition

        A first mandatory parameter is a structure name.
        Everything after that will be template parameters.
        Arguments after '-', become template parameters of the outer structure.

        Example:
        <pre>
          mfc(foo, T, U, -, V1..3)
        </pre>

        will expand into:
        <pre>
        template <typename V1, typename V2, typename V3>
        struct foo
        {
            template <typename T, typename U>
            struct apply
            {
            }
        };
        </pre>
    '''
    data = {}
    data['entity_type'] = 'struct'
    data['entity_description'] = 'Metafunction-class'

    # If 'name' parameter present -- use it!
    if 'name' in kw:
        data['entity_name'] = kw['name']

    template_params = [[], []]
    idx = 0
    for arg in argc:
        if arg == '-':
            data['template'] = True                         # It will be a template despite of other params...
            idx = 1
        elif 'entity_name' not in data:
            # Assume first not recognized parameter is a class name
            # (if latter was not provided via named parameters)
            data['entity_name'] = arg
        else:
            template_params[idx] += arg_helpers.try_expand_params_seq(arg)

    if template_params[0]:
        data['mfc_params'] = template_params[0]

    if template_params[1]:
        data['template_params'] = template_params[1]

    if 'entity_name' not in data:
        data['entity_name'] = 'name'

    return data

@expand.jinja('class.tpl')
@expand.postprocess
def cl(*args, **kw):
    ''' C++ skeleton class generator.

        It takes the following params to control some generation aspects:

        * 'c' generate default constructor
        * 'cN' generate constructor w/ N parameters
        * 'cc' generate copy constructor and assign operator
        * 'mc' generate move constructor and assign operator
        * 'd' generate destructor
        * 't' all parameters after 't' considered as template parameter name
        * '-' or '0' back to "normal" mode

        'c', 'cc', 'mc' may have the following prefixes:

        * '@' to generate defaulted member
        * '!' to generate deleted member

        If template parameter name has the following format: Ln..m,
        where 'L' letter sequence, 'n' and 'm' are numbers (start and end),
        when it produce 'Ln, Ln+1, ..., Lm-1, Lm' parameters sequence.

        Examples:
        // Make a class w/ defaulted default constructor and virtual destructor
        cl(@c,vd)
        // deleted copy ctor, default move ctor, ctor w/ 3 params, set class name to 'Sample'
        cl(Sample,!cc,@mc,c3)
        //
        cl(c,cc,mc,vd,name=Sample)
        cl(!mc,!cc,Sample)

        NOTE that class name can be given as a named parameter. If no named parameter present,
        first 'unknown' parameter will be used as class name.
    '''
    kate.kDebug('@class renderer: arguments: {}'.format(repr(args)))
    kate.kDebug('@class renderer: named arguments: {}'.format(repr(kw)))

    data = {}
    data['entity_type'] = 'class'

    # If 'name' parameter present -- use it!
    if 'name' in kw:
        data['entity_name'] = kw['name']

    data['ctor_arity'] = 0

    # Map positional args to various class properties
    template_params = []
    template_mode = False
    for arg in args:
        if template_mode:                                   # Collect template parameter names
            if arg == '-' or arg == '0':                    # Switch to 'normal' mode
                template_mode = False
            else:
                template_params += arg_helpers.try_expand_params_seq(arg)
        elif arg[0] == '@' or arg[0] == '!':                # Handle defaulted and deleted functions
            fn_kind = 'default' if arg[0] == '@' else 'delete'
            fn_val = arg[1:]
            if fn_val in _CL_SHORTCUT_MAPPINGS:
                data[_CL_SHORTCUT_MAPPINGS[fn_val]] = fn_kind
            else:
                kate.kDebug('Ignore invalid param: {}'.format(arg))
        elif arg in _CL_SHORTCUT_MAPPINGS:
            data[_CL_SHORTCUT_MAPPINGS[arg]] = True
        elif 1 < len(arg) and arg[0] == 'c':                # get default ctor arity
            try:
                arity = int(arg[1:])
                if arity:
                    data['ctor_arity'] = arity
                elif arity == 0:
                    data['default_ctor'] = True
            except:
                kate.kDebug('Ignore invalid param: {}'.format(arg))
        elif arg == 't':                                    # 't' == class is a template, next params are names
            data['template'] = True
            template_mode = True
        elif 'entity_name' not in data:
            # Assume first not recognized parameter is a class name
            # (if latter was not provided via named parameters)
            data['entity_name'] = arg
        else:
            kate.kDebug('Ignore invalid param: {}'.format(arg))

    if template_params:
        data['template_params'] = template_params

    if 'entity_name' not in data:
        data['entity_name'] = 'name'

    if 'virtual_destructor' in data:
        data['destructor'] = True

    return data


def t(*params):
    ''' Render template header w/ given template's parameters list<br/>

        <pre>
        t(type1, ..., typeN)
        </pre>
    '''
    return 'template <typename ' + ', typename '.join(params) + '>'


@expand.jinja('brief.tpl')
def brief():
    '''Render a Doxygen <code>brief</code> header'''
    return {}


@expand.postprocess
def ns(name = None):
    ''' Insert named or anonymous namespace<br/>

        <pre>
        ns([name[::nested[::name]]])
        </pre>
    '''
    params = []
    if bool(name):
        pos = 60
        if 'commentStartPos' in kate.configuration:
            pos = kate.configuration['commentStartPos']

        nsList = [ns.strip() for ns in name.split('::')]
        params.append(' { namespace '.join(nsList))         # NS header
        params.append('}' * len(nsList))                    # NS close curve brackets
        params.append(' ' * (pos - len(nsList)))            # space padding before comment
        params.append(', '.join(reversed(nsList)))          # NS close comment line
        template = _NS_TPL
    else:
        template = _ANONYMOUS_NS_TPL
    return template.format(*params)


@expand.jinja('getter-setter.tpl')
@expand.postprocess
def gs(member_name=None, member_type=None, ref = False, srs = False):
    ''' Insert getter/setter for a data member<br/>

        <pre>
        gs(member-name, member-type[, ref=1][, srs=True])
        </pre>

    ref == getter returns a reference, setter accepts a new value by reference
    srs == setter returns self

    NOTE If the member has a one of "standard" prefix <code>'m_'</code> or suffix <code>'_'</code>,
        accessor name will be w/o it!
    '''
    data = {}
    data['use_reference'] = arg_helpers.looks_like_true(ref)
    data['setter_returns_self'] = arg_helpers.looks_like_true(srs)
    data['member_type'] = member_type if member_type is not None else 'type'
    member_name = member_name if member_name is not None else 'member_name'
    data['member_name'] = member_name

    if member_name.startswith('m_'):                        # Usual code style: members start w/ 'm_' prefix
        pure_name = member_name[2:]
    elif member_name.endswith('_'):                         # Google code style: members end w/ '_' suffix
        pure_name = member_name[0:-1]
    else:
        pure_name = member_name

    data['getter_name'] = pure_name
    data['setter_name'] = pure_name

    return data


@expand.jinja('main.tpl')
@expand.postprocess
def main(need_args=False):
    ''' Render a <code>main()</code> function

        <pre>
        main([1|0])
        </pre>
        if arg is <code>0</code> main will be w/o parameters, default <code>1</code>
    '''
    return {'need_args': arg_helpers.looks_like_true(need_args) }


@expand.jinja('switch.tpl')
@expand.postprocess
def sw(*args):
    ''' Render a <code>switch()</code> statement w/ a list of cases

        <pre>
        sw(expr, case1, ..., caseN)
        </pre>
        If caseX == <code>d</code> or <code>default</code> --> render <code>default: break;</code>
        instead of case
    '''
    data = {}
    cases = []

    if args:
        data['expression'] = args[0]

    for arg in args[1:]:
        if arg == 'd':
            data['default'] = True
        else:
            cases.append(arg)

    if cases:
        data['cases'] = cases
    return data


# kate: hl python; indent-width 4;
