# -*- coding: utf-8 -*-
#
# NOTE Expansion plugin can complete available expansion functions for current
# document. To get help (via tooltip) for the selected expansion function use
# Ctrl+Shift+E shotcut.
#

import kate
from libkatepate import ui

_BRIEF_DOC_TPL = '''/**
 * \\brief Class \c {0}
 */'''

_TEMPLATE_PARAMS_TPL = '''
template <{1}>'''

_CLASS_BODY_TPL = '''
class {0}
{{
public:
\t/// Default constructor
\t%{{cursor}}explicit {0}()
\t{{
\t}}
\t/// Destructor
\tvirtual ~{0}()
\t{{
\t}}
}};
'''

_STRUCT_BODY_TPL = '''
struct {0}
{{
\t%{{cursor}}
}};
'''

_MFC_TPL = '''/**
 * \\brief Metafunction class \c {0}
 */
struct {0}
{{
\ttemplate <{1}>
\tstruct apply
\t{{
\t\ttypedef %{{cursor}} type;
\t}};
}};
'''

_PURE_BRIEF_DOC_TPL = '''/**
 * \\brief %{cursor}
 */'''

_NS_TPL = '''namespace {0} {{
%{{cursor}}
{1}{2}// namespace {3}
'''

_ANONYMOUS_NS_TPL = '''namespace {{
%{{cursor}}
}}                                                           // anonymous namespace
'''

_GET_SET_TPL = '''{0} {1}() const
{{
    return {2};
}}
void {1}({0} value)
{{
    {2} = value;
}}%{{cursor}}
'''

_MAIN_WITH_ARGS_TPL = '''int main(int argc, const char* const argv[])
{
\t%{cursor}
\treturn 0;
}
'''

_MAIN_TPL = '''int main()
{
\t%{cursor}
\treturn 0;
}'''

_EMPTY_SWITCH_TPL = '''switch (%{cursor})
{
\tcase :
\t\tbreak;
\tdefault:
\t\tbreak;
}'''

_SWITCH_TPL = '''switch ({})
{{
{}
}}'''


def st(name, *templateParams):
    ''' Insert a structure definition<br/>

        A first mandatory parameter is a structure name.
        Everything after that will be template parameters.
        <pre>
          st(foo, T, U, V)
        </pre>

        will expand into:
        <pre>
          template <typename T, typename U, typename V>
          struct foo
          {
          };
        </pre>
    '''
    params = [name]
    if len(templateParams):
        template = _BRIEF_DOC_TPL + _TEMPLATE_PARAMS_TPL + _STRUCT_BODY_TPL
        params.append('typename ' + ', typename '.join(templateParams))
    else:
        template = _BRIEF_DOC_TPL + _STRUCT_BODY_TPL
    print('template="{}", params={}'.format(template, repr(params)))
    return template.format(*params)


def mfc(name, *templateParams):
    ''' Insert a metafunction class definition<br/>

        A first mandatory parameter is a structure name.
        Everything after that will be template parameters.
        <pre>
          mfc(foo, T, U, V)
        </pre>

        will expand into:
        <pre>
        struct foo
        {
            template <typename T, typename U, typename V>
            struct apply
            {
            }
        };
        </pre>
    '''
    params = [name]
    if len(templateParams):
        params.append('typename ' + ', typename '.join(templateParams))
        return _MFC_TPL.format(*params)
    return st(name)                                         # Just return a usual structure...


def cl(name, *templateParams):
    ''' Insert a class definition<br/>

        <pre>
        cl(name, [type1, ..., typeN])
        </pre>

        If there some type(s) specified, class will be turned into a template
        with given template parameters.
    '''
    # TODO It would be neat to have syntax like this:
    #   cl(test, T, U, d=v, cc=del, mv=def)
    # i.e. define a class 'test' w/ template params T and U,
    # w/ virtual dtor, w/ deleted copy ctor/assign and w/
    # defaulted move ctor/assign.
    # Isn't it?
    params = [name]
    if len(templateParams):
        template = _BRIEF_DOC_TPL + _TEMPLATE_PARAMS_TPL + _CLASS_BODY_TPL
        params.append('typename ' + ', typename '.join(templateParams))
    else:
        template = _BRIEF_DOC_TPL + _CLASS_BODY_TPL
    return template.format(*params)


def t(*params):
    ''' Render template header w/ given template's parameters list<br/>

        <pre>
        t(type1, ..., typeN)
        </pre>
    '''
    return 'template <typename ' + ', typename '.join(params) + '>'


def brief():
    '''Render a Doxygen <code>brief</code> header'''
    return _PURE_BRIEF_DOC_TPL


def ns(name = None):
    ''' Insert named or anonymous namespace<br/>

        <pre>
        ns([name[::nested[::name]]])
        </pre>
    '''
    params = []
    if bool(name):
        pos = 60
        if 'commentStartPos' in kate.configuration:
            pos = kate.configuration['commentStartPos']

        nsList = [ns.strip() for ns in name.split('::')]
        params.append(' { namespace '.join(nsList))         # NS header
        params.append('}' * len(nsList))                    # NS close curve brackets
        params.append(' ' * (pos - len(nsList)))            # space padding before comment
        params.append(', '.join(reversed(nsList)))          # NS close comment line
        template = _NS_TPL
    else:
        template = _ANONYMOUS_NS_TPL
    return template.format(*params)


def gs(typeT, name, ref = None):
    ''' Insert getter/setter for a data member<br/>

        <pre>
        gs(type, member-name, [set-by-ref=1])
        </pre>

    NOTE If the member has a one of "standard" prefix <code>'m_'</code> or suffix <code>'_'</code>,
        accessor name will be w/o it!
    '''
    template = _GET_SET_TPL

    if ref == None:
        arg = typeT
    else:
        arg = 'const ' + typeT + ref

    if name.startswith('m_'):                               # Usual code style: members start w/ 'm_' prefix
        pure_name = name[2:]
    elif name.endswith('_'):                                # Google code style: members end w/ '_' suffix
        pure_name = name[0:-1]
    else:
        pure_name = name

    return template.format(arg, pure_name, name)


def main(need_args=True):
    ''' Render a <code>main()</code> function

        <pre>
        main([1|0])
        </pre>
        if arg is <code>0</code> main will be w/o parameters, default <code>1</code>
    '''
    if need_args != '0':
        return _MAIN_WITH_ARGS_TPL
    return _MAIN_TPL


def sw(expr = None, *caseList):
    ''' Render a <code>switch()</code> statement w/ a list of cases

        <pre>
        sw(expr, case1, ..., caseN)
        </pre>
        If caseX == <code>d</code> or <code>default</code> --> render <code>default: break;</code>
        instead of case, so it is better to put <code>d</code> at the end of parameters list.
    '''
    if expr:
        if caseList:
            caseStr = ''
            for case in caseList:
                if case == 'd' or case == 'def' or case == 'default':
                    caseStr += '\tdefault:\n\t\tbreak;\n'
                else:
                    caseStr += '\tcase ' + case +':\n\t\tbreak;\n'
            caseStr += '%{cursor}'
        else:
            caseStr = '\tcase %{cursor}:\n\t\tbreak;\n'
        return _SWITCH_TPL.format(expr, caseStr)
    return _EMPTY_SWITCH_TPL

# kate: hl python; indent-width 4;
